# 함수형 아키텍처

지금까지 파악한 도메인을 어떻게 함수형 프로그래밍 아키텍처로 녹여낼 것인지가 다음 과제입니다.  
사이먼 브라운의 **C4 접근법**에 따르면 소프트웨어 아키텍처는 다음의 네 가지 계층으로 이뤄집니다.

- '시스템 맥락'은 최상위 레벨로 전체 시스템을 나타냅니다.
- 시스템 맥락은 웹사이트, 웹서비스, 데이터베이스 등과 같은 배포 단위인 '컨테이너'들로 이뤄집니다.
- 다시 개별 컨테이너는 코드룰 구성하는 주요소인 '컴포넌트'들로 이뤄집니다.
- 마지막으로 각 컴포넌트는 일련의 저수준 메서드나 함수를 포함하는 '클래스'들로 이뤄집니다.

**좋은 아키텍처의 목표는 컨테이너, 컴포넌트, 모듈 간의 다양한 경계를 정의하여 새로운 요구사항 발생에 따른 '변경 비용'을 최소화하는 것입니다.**

## 경계 진 맥락을 자율적인 소프트웨어 컴포넌트로

경계 진 맥락(Bounded Context)은 **명확하고 자율적인 하위 시스템**이어야 한다는 제약이 있습니다.  
이러한 제약에 적용할 수 있는 아키텍처 스타일은 여러 가지가 있습니다.

| 아키텍처 스타일 | 특징 | 경계 진 맥락 처리 방식                                    |
| :--- | :--- |:-------------------------------------------------|
| **전통적인 서비스 지향 아키텍처 (SOA)** | 시스템을 한 덩어리(모놀리식)로 배포 단위, 또는 C4 용어의 **단일 컨테이너**로 구현 | 각 경계인 맥락을 **명확한 별도 패키지**에 대응시키고, **별도 컨테이너**로 배포 |
| **마이크로서비스 아키텍처 (MSA)** | 개발 작업 흐름별로 **독립된 컨테이너**를 만들어 세분화 | 경계인 맥락끼리 **분리되어 자율성**을 유지                        |

경계를 올바르게 설정하는 것이 중요하지만, 프로젝트 초기에는 경계 설정이 어려울 수 있습니다.  
처음에는 시스템을 모놀리식으로 구축하여 도메인을 알아가면서 구현하는 것이 좋습니다.  
필요에 따라 분리된 컨테이너로 리팩터링하는 것이 훨씬 수월합니다.  
마이크로서비스가 갖는 이점이 확실히 크지 않다면, 운영에 추가 비용을 지불하면서 곧장 마이크로서비스로 묶을 필요는 없습니다.

## 경계 진 맥락 간의 소통

경계 진 맥락간의 소통은 일반적으로 이벤트를 사용하여 구현됩니다.

1.  주문 접수 맥락의 주문 접수 작업 흐름은 **`OrderPlaced`** 이벤트를 발행합니다.
    * `OrderPlaced` 이벤트는 **큐(queue)** 등에 게시됩니다.
2.  배송 맥락은 **`OrderPlaced`** 이벤트를 수신합니다.
3.  이벤트를 수신하면 **`ShipOrder` 명령**이 생겨납니다.
4.  `ShipOrder` 명령은 배송 작업 흐름을 시작합니다.
5.  주문 배송 작업 흐름을 성공적으로 마치면 **`OrderShipped`** 이벤트를 발행합니다.

<img width="653" height="223" alt="Image" src="https://github.com/user-attachments/assets/10a435cf-8901-407a-b8b3-4d372f22ac7f" />

위 다이어그램에서 볼 수 있듯이, 두 맥락은 서로를 인식하지 못하며 이벤트만을 통해서 비동기적으로 통신합니다.  
맥락의 완전한 자율성을 보장하려면, 이처럼 맥락을 분리하는 것이 중요합니다.  
맥락 간에 이벤트를 전송하는 방식은 아키텍처마다 다르지만, 비동기 통신에 적합한 마이크로서비스나 에이전트로 구현하는 것이 첫 번째 선택지가 됩니다. 모놀리식 시스템에서도 시스템 분리를 위해 이 방식을 사용할 수 있습니다.

내부의 큐로 이벤트를 전송할 수도 있고, 상위 맥락에서 하위 맥락의 함수를 호출하여 직접 연결할 수도 있습니다.  
맥락끼리 분리되도록 디자인했다면, 이벤트를 전송하는 방식을 지나치게 고민할 필요는 없습니다.

### 경계 진 맥락 간 데이터 전송

경계 진 맥락간에 전송되는 이벤트는 단순히 발생 신호만을 포함하는 것이 아니라, 해당 이벤트를 처리하는 데 필요한 모든 데이터를 함께 포함하고 있습니다.  
예를 들어, OrderPlaced 이벤트는 주문 접수 맥락에서 접수된 주문에 대한 모든 정보를 담고 있습니다.  
이렇게 필요한 모든 정보를 이벤트에 담아 전송하면, 이를 수신하는 하위 맥락(예: 배송 맥락)이 ShipOrder 명령을 실행할 때 공유 데이터 저장소에 접근하거나 추가적인 데이터 전송을 요청할 필요 없이 작업을 처리할 수 있습니다.

맥락 간에 주고받는 데이터 객체는 각 맥락이 내부적으로 사용하는 도메인 객체와 완전히 동일하지 않고, 오히려 **DTO(Data Transfer Object)** 와 같은 전송용 객체를 사용합니다.
- DTO의 필요성: 데이터 객체는 맥락을 넘나드는 인프라의 일부로서 데이터를 직렬화하고 맥락끼리 공유하는 데 적합하게 설계됩니다.
- 용어의 차이: 이러한 전송 객체를 데이터 전송 객체라고 부르며, DDD 외부에서는 종종 공유 데이터 객체나 이벤트 자체로 불리기도 합니다.
- 데이터 구성: OrderPlaced 이벤트는 주문 맥락의 도메인 객체와 같은 필드와 정보를 가지고 있지만, 그 목적과 사용되는 맥락에 따라 명칭이나 구성 요소가 다를 수 있습니다.

경계 진 맥락 간의 데이터 전송은 직렬화(Serialization)와 역직렬화(Deserialization) 과정을 거칩니다.  

1. 상위 맥락(발신)에서의 직렬화
   1. 변환: 상위 맥락의 경계에서 도메인 객체가 DTO로 변환됩니다.  
   2. 직렬화: 이 DTO 타입은 JSON이나 XML과 같은 형식으로 직렬화되어 하위 맥락으로 전송됩니다.
2. 하위 맥락(수신)에서의 역직렬화
   1. 역직렬화: 하위 맥락에서는 수신된 JSON/XML 데이터를 역직렬화하여 DTO 타입으로 변환합니다. 
   2. 변환: 이 DTO를 다시 하위 맥락의 비즈니스 로직에 맞는 도메인 객체로 변환하여 사용합니다.

**이러한 과정을 통해 각 맥락은 독립성과 자율성을 유지하면서 필요한 데이터를 안전하게 주고받을 수 있습니다.**

### 신뢰 경계와 검증

경계 진 맥락의 경계는 **신뢰 경계**의 역할을 수행합니다. 경계 진 맥락의 내부는 신뢰할 수 있는 영역이지만, 그 외부 세계는 결코 신뢰할 수 없으며 잘못된 데이터를 포함할 수 있습니다.  
따라서 맥락 내부의 '우아하고 깔끔한 도메인 모델'을 보호하고 외부 세계와 안전하게 소통하기 위해 **'입구'**와 **'출구'**라는 중개 지점을 도입합니다.  

**입구**의 핵심 역할은 **검증**입니다. 외부에서 DTO 형태로 들어오는 데이터는 도메인 모델이 요구하는 제약 조건(예: 특정 필드는 null이 아니어야 하거나, 최대 길이를 넘어서는 안 됨)을 만족하는지 확인해야 합니다.  
맥락 밖에서 들어온 데이터는 임의의 값을 가질 수 있기 때문에, 입구에서 이 DTO를 엄격하게 검증하여 통과한 경우에만 비로소 유효한 **도메인 객체**로 변환되어 내부 작업 흐름으로 전달됩니다.  
만약 검증에 실패하면, 나머지 작업 흐름을 진행하지 않고 즉시 오류를 발생시켜 신뢰할 수 없는 데이터가 내부 로직에 침투하는 것을 방지합니다.

반면, **출구**의 역할은 **결합 방지 및 보안**입니다. 출구는 맥락 내부의 모든 정보를 외부로 유출하는 것을 막아 맥락 간의 불필요한 **결합**을 최소화합니다.  
또한, 내부적으로는 필요하지만 외부에는 노출되어서는 안 되는 **민감한 정보**를 필터링하여 보안을 지킵니다.  
예를 들어, 배송 맥락에서 주문 데이터를 외부에 전달할 때, 결제 정보인 신용카드 번호는 의도적으로 **DTO 변환 과정에서 누락**시켜 전송하는 방식입니다.  
결론적으로, 입구와 출구는 경계 진 맥락이 외부의 영향을 최소화하고 자율성을 유지하며 안전하게 운영될 수 있도록 보장하는 필수적인 보호 장치입니다.

## 경계 진 맥락 간의 계약

경계 진 맥락들이 독립성을 유지하면서도 서로 소통하기 위해서는, 각 맥락 간의 **결합을 최소화**하는 것이 중요합니다. 
이를 위해 이벤트나 DTO를 매개로 일종의 **소통 계약**을 맺고, 이 계약에 따른 **공통 양식**에 동의해야 합니다.  
DDD(Domain-Driven Design) 커뮤니티는 이러한 상호작용의 유형을 세 가지 주요 관계로 정의하여 맥락 간의 관계를 명확히 관리합니다.

#### 첫 번째는 **공유 커널 (Shared Kernel)** 관계입니다.  

이 관계는 두 맥락이 도메인 디자인의 일부(예: 배송 주소 데이터 구조)를 함께 공유할 때 발생하며, 이 공유된 커널과 관련된 팀들은 반드시 협력해야 합니다.  
한 맥락이 공유 커널의 이벤트나 DTO를 변경할 경우, 다른 맥락에 직접적인 영향을 미치기 때문에 변경 전에 반드시 영향을 받는 맥락의 소유자와 **합의**를 거쳐 신중하게 진행해야 합니다.

#### 두 번째는 **고객/공급자 (Customer/Supplier)** 관계, 또는 **소비자 주도 계약 (Consumer Driven Contract)** 관계입니다. 

이 경우, 하위 맥락(고객/소비자)이 상위 맥락(공급자)에게 필요한 데이터와 양식에 대한 **계약을 정의**하고, 상위 맥락이 이를 준수하여 정보를 제공합니다.  
하위 맥락은 계약만 유지된다면 상위 맥락의 내부적인 변화에 크게 영향받지 않고 **독립적으로 진화**할 수 있습니다.  
예를 들어, 청구 맥락이 청구서 작성을 위해 필요한 정보를 명확히 정의하면, 주문 접수 맥락은 그 요구사항에 맞춰 정보를 제공하는 방식이 여기에 해당합니다.

#### 마지막은 **순응자 (Conformist)** 관계입니다. 

이는 고객/공급자 관계와는 반대로, 하위 맥락(소비자)이 상위 맥락(공급자)이 이미 **정해 놓은 계약을 수락**하고, 자신의 도메인 모델까지도 그 계약에 맞추어 **조정**하는 관계입니다.  
만약 상위 맥락의 디자인이나 표준이 강력하고 이미 잘 정립되어 있다면, 하위 맥락은 굳이 자체적인 변환 계층을 만들지 않고 이 계약에 순응하는 것이 더 효율적일 수 있습니다.  
예를 들어, 내부 주문 시스템이 외부 제품 카탈로그 맥락이 정의한 제품 코드 체계를 그대로 받아 사용하는 경우가 순응자 관계에 해당합니다.

### 부패 방지 계층

경계 진 맥락이 **외부 시스템**과 소통할 때, 외부 시스템이 제공하는 인터페이스나 데이터 양식이 맥락 내부의 **도메인 모델**과 일치하지 않는 경우가 빈번하게 발생합니다.  
이 경우, 맥락은 외부 시스템과 상호작용하는 방식을 바꾸거나 주고받는 데이터를 내부 도메인 모델에서 사용하기에 **적합한 형태로 변환**해야 합니다.  
이러한 변환 과정이 없다면, 외부 시스템 모델의 "부패한" 지식이 내부의 순수한 도메인 모델을 **훼손**시킬 위험이 있습니다.

이렇게 맥락 간의 독립성을 강화하고 외부의 오염으로부터 내부 도메인을 보호하는 역할을 하는 것을 DDD 용어로 **부패 방지 계층(Anti-Corruption Layer, ACL)** 이라고 부릅니다.  
앞선 내용에서 살펴보았던 **'입구'** 는 종종 이러한 ACL의 역할을 수행합니다.   
즉, ACL은 외부 세계의 불완전하거나 일관되지 않은 지식에 의해 내부의 **순수한 도메인 모델**이 **'부패'하는 것을 방지**하는 핵심 방어선입니다.

ACL의 진정한 목적은 단순한 유효성 검사나 데이터 부패 방지 그 이상입니다. 그것은 **상위 맥락의 공용어**를 **하위 맥락의 공용어로 '번역'** 하는 데 있습니다.    
예를 들어, 주문 접수 맥락이 외부의 주소 확인 서비스와 소통할 때, 외부 서비스가 사용하는 데이터 양식이나 언어(유비쿼터스 언어)를 주문 접수 맥락이 이해하는 **'배송'** 이라는 맥락의 용어와 개념으로 번역하는 것입니다.   
이를 통해 주문 접수 맥락이 외부에 휘둘려 도메인 모델이 왜곡되지 않도록 보호할 수 있습니다.

### 맥락 간의 관계를 나타내는 맥락 지도

<img width="533" height="331" alt="Image" src="https://github.com/user-attachments/assets/cdfd1e9e-9032-40bc-a6c0-28056cd45160" />

맥락 지도가 단순히 기술적인 관계에서 그치지 않고, 각 맥락을 소유한 팀 간의 관계도 드러내어 이들이 어떻게 협력할지도 보여줍니다.  
도메인이 상호작용하는 방식을 결정하는 것은 종종 기술적인 과제를 넘어 조직 구성에 대한 과제이기도 합니다.

## 경계 진 맥락의 작업 흐름

<img width="378" height="269" alt="Image" src="https://github.com/user-attachments/assets/1a9bad1d-aac8-4fd3-8d65-de9b8a940427" />

함수형 아키텍처는 작업 흐름을 명령 객체를 입력받아서 이벤트 객체들을 출력하는 단일 함수로 구현합니다.  
모든 작업 흐름은 반드시 단일 맥락에 속하며, 여러 맥락을 관통하는 '엔드 투 엔드'로 작업 흐름을 구현하지 않습니다.

### 작업 흐름 입력 및 출력

작업 흐름(Work Flow)은 항상 **명령(Command)** 형태의 데이터를 입력으로 받아 처리하며, 그 결과로 다른 맥락에 전달할 **이벤트**들을 출력합니다.  
여기서 중요한 점은, 주문 접수 맥락과 청구 맥락의 관계가 **'고객/공급자(Customer/Supplier)'** 관계라면, `OrderPlaced` 이벤트 전체를 그대로 청구 맥락에 보내는 것이 아니라, **청구 맥락이 요청한 정보만** 담아서 보내야 한다는 것입니다.

즉, `OrderPlaced` 이벤트에는 주소, 청구 총액 등 청구에 필요한 정보는 포함되어 있지만, 배송 주소나 항목 목록처럼 청구와 관련 없는 데이터도 포함되어 있을 수 있습니다.   
따라서 작업 흐름은 이러한 불필요한 데이터를 걸러내고 청구 맥락만을 위한 **새로운 이벤트**를 생성해야 합니다.   
이 새로운 이벤트의 예시가 **`BillableOrderPlaced`**이며, 이 이벤트는 `OrderId`, `BillingAddress`, `AmountToBill`과 같이 청구에 필요한 최소한의 데이터만 포함하도록 설계됩니다.

```json
data BillableOrderPlaced =
    OrderId
    AND BillingAddress
    AND AmountToBill
```

<img width="638" height="296" alt="Image" src="https://github.com/user-attachments/assets/93706b19-e8fd-451b-9c80-7af64b5e5082" />

### 경계 진 맥락 내 도메인 이벤트 금지

객체지향 디자인에서는 경계 진 맥락 안에서 내부 도메인 이벤트가 발생하는 것이 일반적입니다.

<img width="775" height="323" alt="Image" src="https://github.com/user-attachments/assets/49da0e9e-cf02-4cd9-be4d-3ccfb31db383" />

<br>



<img width="774" height="319" alt="Image" src="https://github.com/user-attachments/assets/b38c01d4-878c-48b5-8796-2c0e2f22bb91" />


**함수형 디자인에서는 이 접근법을 사용하지 않는 것이 좋습니다. 숨겨진 종속성을 만들기 때문입니다.**  
대신 이벤트에 대한 '리스너'기 필요한 경우 다음과 같이 작업 흐름 끝에 추가하면 됩니다.  
이 접근법은 더 명시적이고 가변 상태를 가진 글로벌 이벤트 관리자가 없으므로, 이벤트 생성 로직을 이해하고 유지보수하는데 용이합니다.

## 경계 진 맥락의 코드 구조

<img width="404" height="314" alt="Image" src="https://github.com/user-attachments/assets/522049ff-7e5a-41a0-8cfb-c4a218a4d1af" />

전통적인 소프트웨어 아키텍처는 코드를 여러 계층으로 구조화하며, 일반적으로 **사용자 인터페이스 및 API 계층**, **서비스 계층**, **도메인 계층**, 그리고 **데이터베이스 계층**으로 나뉩니다.  
작업 흐름은 최상위 계층(API/인터페이스 계층)에서 시작하여 최하위 계층(데이터베이스 계층)까지 내려갔다가 다시 최상위 계층으로 돌아오는 방식으로 실행됩니다.

이러한 방식은 중요한 디자인 원칙인 **'같이 변경할 코드는 함께 모여 있어야 한다'** 를 위반하는 경우가 많습니다.  
같은 계층, 즉 **'수평'** 방향으로 같은 위치에 여러 작업 흐름의 코드를 같이 모아두기 때문에, 특정 작업 흐름에 대한 요구사항을 수정하려면 그 작업 흐름에 관여하는 **모든 계층의 코드**를 찾아 수정해야 하는 비효율성이 발생합니다.

### 양파 아키텍처

<img width="491" height="255" alt="Image" src="https://github.com/user-attachments/assets/959db3a4-f66e-4f93-b2ca-0654e7d6ef7a" />

도메인 코드를 중심에 두고 그 외 측면들이 도메인을 에워싸게 배치합니다.  
각 계층은 자신보다 안쪽 계층에만 의존하고 외부 방향으로는 의존하지 않는다는 규칙을 따릅니다.  
**모든 의존 방향을 안쪽으로 모으기 위해서는 함수형 스타일 의존 주입을 써야합니다.**

### 외부 입출력을 맥락 경계로 내몰기

함수형 프로그래밍의 주요 목표 중 하나는 **예측 가능**하고 추론하기 쉬운 함수들로 프로그래밍하는 것이며, 이를 위해 함수의 의존성을 숨기지 않고 드러내는 동시에 **불변 데이터**를 다루는 데 중점을 둡니다.   
이 목표를 달성하는 데 있어 가장 중요한 원칙은 함수 내에서 **부수 효과(Side Effect)** 를 피하는 것입니다. 부수 효과란 프로그램의 상태 변경, 데이터베이스나 파일 시스템에 읽거나 쓰는 모든 종류의 **외부 입출력(I/O)** 을 포함합니다.  
따라서 데이터베이스 접근과 같이 **'불순한(Impure)'** 것으로 간주되는 함수들은 핵심 도메인 모델에서는 피해야 합니다.

그렇다면 데이터 읽기/쓰기는 어디서 수행해야 할까요?   
답은 모든 외부 입출력을 시스템의 **가장자리**로 밀어내는 것입니다. 예를 들어 데이터베이스 접근은 **작업 흐름(Work Flow)의 시작이나 끝**에서만 수행하고, 작업 흐름 **내부**에서는 수행하지 않도록 합니다.

이러한 방식은 **'관심사 분리'** 라는 추가적인 이점을 제공합니다.
- **코어 도메인 모델**은 오직 **비즈니스 로직**만을 다루게 됩니다.
- **영속화(Persistence)** 및 기타 외부 입출력과 관련된 인프라 관심사는 **경계의 가장자리**에서 처리됩니다.

실제로 외부 입출력과 데이터베이스 접근을 경계의 가장자리로 밀어내는 관행은 이전 장에서 다루었던 **부패 방지 계층**과 같은 개념과도 잘 맞아떨어집니다.  
작업 흐름 내부에서 데이터베이스 접근이 불가능하다면, 데이터베이스를 사용한 **도메인 모델링 자체가 불가능**해지는 극단적인 상황이 발생할 수도 있지만, 이는 영속화 방법을 자세히 다루는 후속 장에서 다루게 될 별개의 문제입니다.   
핵심은 순수한 도메인 모델을 유지하기 위해 불순한 I/O 작업을 분리하는 것입니다.









